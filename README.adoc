= VPN

link:docs/DESGIN.adoc[Design]
link:docs/schema.d2[Schema]

AWS allows assignments of private addresses to elastic network interfaces in
/28 blocks. The prefixes are directed to the interface allowing you to use all
sixteen addresses from the /28, as they are usually coming from a larger
/20 or /16 depending on your VPC.

A prefix can take the same "slot" as an ip address, but you must have one
private address on each interface. Instance types can have varying amounts of
network interfaces and ip addresses per interface seen https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AvailableIpPerENI.html[in the aws docs].

**NOTE:** It may be true that there is an upper limit to prefixes that you
exceed before filling all of the slots. We haven't tried to see _how many_
addresses you can really point at one instance.

Using this example:
|===
|IPv4 Per ENI|Max ENI|Instance Type
|15|4|c5.xlarge
|2|2|t3.micro
|===
You can see that you have a maxiumum of four ENIs and 15 addresses per ENI.
This means that with this model you could allocate 4 * 14 * 16 + 4 = 900 private
addresses to a c5.xlarge. Now we don't really need that many so we like to use
`t3.micro`s because they're cheap.
The `t3.micro` has a maximum of 2 * 1 * 16 + 2 = 34 .. enough for now.


== Setup

See `userdata.sh`

ami-0b40807e5dc1afecf
* use systemd-networkd
** Add addresses with userdata
* configure for static addressing
* assign static private ipv4 address as primary, then map to elastic ip
* Set DNS/Gateway/NTP in networkd file
* Remove netplan
** remove /run/systemd/network -> generated by netplan
* Stop cloud-init from configuring network on restart


== Configuration

Inbound traffic can reach the primary interface on the static primary address

All _prefix_ addresses are used as switches to other endpoints.
Every prefix contains 16 usable addresses.
Every prefix will take up a normal address slot on an interface.
Some instance types have more "slots" per interface limits.
The `t3.micro` has 2.
We'll use one primary address and one prefix per interface, to keep things simple.

Incoming traffic destined for a proxied endpoint should be re-routed with SNAT/DNAT.


23:40:04.105939 IP 24.62.90.185.49376 > 172.31.16.17.22: Flags [P.], seq 4949:4985, ack 6625, win 501, options [nop,nop,TS val 2784531092 ecr 997300070], length 36
23:40:04.106149 IP 172.31.16.17.22 > 24.62.90.185.49376: Flags [P.], seq 6625:6677, ack 4985, win 460, options [nop,nop,TS val 997300120 ecr 2784531092], length 52
23:40:04.106196 IP 172.31.16.17.22 > 24.62.90.185.49376: Flags [P.], seq 6677:6721, ack 4985, win 460, options [nop,nop,TS val 997300120 ecr 2784531092], length 44
23:40:04.107910 IP 172.31.16.17.22 > 24.62.90.185.49376: Flags [P.], seq 6721:6897, ack 4985, win 460, options [nop,nop,TS val 997300122 ecr 2784531092], length 176


This traffic should be rewritten for the other end of our wireguard tunnel based on the incoming address.

e.g.
ubuntu.devstack.ninja -> A 3.3.3.3
3.3.3.3 associated with 172.31.16.17/20
* part of our 172.31.16.16/28 prefix on ens5
We see inbound traffic destined for this interface
172.31.16.17 -> 10.0.0.2 on wg0
But we redirect it to 10.0.0.2, the endpoint of one of our wireguard tunnels.
For the packet to return to us we need to mark our side of the tunnel as the source and track the
remote initiator of the connection.


Conntrack handles the return-path for these packets after they get NAT

```bash
iptables -tnat -APREROUTING -d 172.31.16.17 -j DNAT --to-dest 10.0.0.2
iptables -tnat -APOSTROUTING -d 10.0.0.2 -j SNAT --to-source 10.0.0.1
```

Output from conntrack:

```bash
    [NEW] tcp      6 120 SYN_SENT src=24.62.90.185 dst=172.31.16.17 sport=52210 dport=22 [UNREPLIED] src=10.0.0.2 dst=10.0.0.1 sport=22 dport=52210
 [UPDATE] tcp      6 60 SYN_RECV src=24.62.90.185 dst=172.31.16.17 sport=52210 dport=22 src=10.0.0.2 dst=10.0.0.1 sport=22 dport=52210
 [UPDATE] tcp      6 300 ESTABLISHED src=24.62.90.185 dst=172.31.16.17 sport=52210 dport=22 src=10.0.0.2 dst=10.0.0.1 sport=22 dport=52210 [ASSURED]
```

== TODO

* create NFT management for connections
* create model for address mapping

* create certificate-based connection enrollment

* disable public ec2-dns
